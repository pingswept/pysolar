
<!-- saved from url=(0052)https://www.esrl.noaa.gov/gmd/grad/solcalc/azel.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>NOAA Solar Position Calculator</title>
<script language="JavaScript">

//***********************************************************************/
//*	DATA STRUCTURES									*/
//***********************************************************************/

	function month(name, numdays, abbr)
	{
		this.name = name;
		this.numdays = numdays;
		this.abbr = abbr;
	}

//*********************************************************************/

	function ans(daySave,value)
	{
		this.daySave = daySave;
		this.value = value;
	}

//*********************************************************************/

	function city(name, lat, lng, zoneHr)
	{
		this.name = name;
		this.lat = lat;
		this.lng = lng;
		this.zoneHr = zoneHr;
	}


//***********************************************************************/
//*	Data for Selectbox Controls							*/
//***********************************************************************/

	var monthList = new Array();	//	list of months and days for non-leap year
	var i = 0;
	monthList[i++] = new month("January", 31, "Jan");
	monthList[i++] = new month("February", 28, "Feb");
	monthList[i++] = new month("March", 31, "Mar");
	monthList[i++] = new month("April", 30, "Apr");
	monthList[i++] = new month("May", 31, "May");
	monthList[i++] = new month("June", 30, "Jun");
	monthList[i++] = new month("July", 31, "Jul");
	monthList[i++] = new month("August", 31, "Aug");
	monthList[i++] = new month("September", 30, "Sep");
	monthList[i++] = new month("October", 31, "Oct");
	monthList[i++] = new month("November", 30, "Nov");
	monthList[i++] = new month("December", 31, "Dec");

//*********************************************************************/

	var YesNo = new Array();	//Daylight Saving array
	i=0;
	YesNo[i++] = new ans("No",0);
	YesNo[i++] = new ans("Yes",60);

//*********************************************************************/

	var City = new Array();

	j = 0;
	City[j++] = new city("Enter Lat/Long -->",0,0,0);
	City[j++] = new city("",0,0,0);
	City[j++] = new city("US CITIES",0,0,0);
	City[j++] = new city("Albuquerque, NM", 35.0833,106.65,7);
	City[j++] = new city("Anchorage, AK", 61.217, 149.90,9);
	City[j++] = new city("Atlanta, GA", 33.733, 84.383, 5);
	City[j++] = new city("Austin, TX", 30.283, 97.733, 6);
	City[j++] = new city("Birmingham, AL", 33.521, 86.8025, 6);
	City[j++] = new city("Bismarck, ND", 46.817, 100.783, 6);
	City[j++] = new city("Boston, MA", 42.35, 71.05, 5);
	City[j++] = new city("Boulder, CO", 40.125, 105.237, 7);
	City[j++] = new city("Chicago, IL", 41.85,87.65,6);
	City[j++] = new city("Dallas, TX", 32.46, 96.47,6);
	City[j++] = new city("Denver, CO", 39.733, 104.983, 7);
	City[j++] = new city("Detroit, MI", 42.333, 83.05, 5);
	City[j++] = new city("Honolulu, HI", 21.30, 157.85, 10);
	City[j++] = new city("Houston, TX", 29.75, 95.35, 6);
	City[j++] = new city("Indianapolis, IN", 39.767, 86.15, 5);
	City[j++] = new city("Jackson, MS", 32.283, 90.183, 6);
	City[j++] = new city("Kansas City, MO", 39.083, 94.567,6);
	City[j++] = new city("Los Angeles, CA",34.05,118.233,8);
	City[j++] = new city("Menomonee Falls, WI",43.11,88.10,6);
	City[j++] = new city("Miami, FL", 25.767, 80.183,5);
	City[j++] = new city("Minneapolis, MN", 44.967, 93.25, 6);
	City[j++] = new city("New Orleans, LA", 29.95, 90.067, 6);
	City[j++] = new city("New York City, NY", 40.7167, 74.0167, 5);
	City[j++] = new city("Oklahoma City, OK", 35.483, 97.533,6);
	City[j++] = new city("Philadelphia, PA", 39.95, 75.15, 5);
	City[j++] = new city("Phoenix, AZ",33.433,112.067,7);
	City[j++] = new city("Pittsburgh, PA",40.433,79.9833,5);
	City[j++] = new city("Portland, ME", 43.666, 70.283, 5);
	City[j++] = new city("Portland, OR", 45.517, 122.65, 8);
	City[j++] = new city("Raleigh, NC", 35.783, 78.65, 5);
	City[j++] = new city("Richmond, VA", 37.5667, 77.450, 5);
	City[j++] = new city("Saint Louis, MO", 38.6167,90.1833,6);
	City[j++] = new city("San Antonio, TX", 29.53, 98.47, 6);
	City[j++] = new city("San Diego, CA", 32.7667, 117.2167, 8);
	City[j++] = new city("San Francisco, CA",37.7667,122.4167,8);
	City[j++] = new city("Seattle, WA",47.60,122.3167,8);
	City[j++] = new city("Washington DC", 38.8833, 77.0333,5);
	City[j++] = new city("",0,0,0);
	City[j++] = new city("WORLD CITIES",0,0,0);
	City[j++] = new city("Beijing, China",39.9167, -116.4167,-8);
	City[j++] = new city("Berlin, Germany",52.33, -13.30, -1);
	City[j++] = new city("Bombay, India", 18.9333, -72.8333, -5.5);
	City[j++] = new city("Buenos Aires, Argentina", -34.60,58.45,3);
	City[j++] = new city("Cairo, Egypt", 30.10,-31.3667,-2);
	City[j++] = new city("Cape Town, South Africa",-33.9167,-18.3667,-2);
	City[j++] = new city("Caracas, Venezuela", 10.50,66.9333,4);
	City[j++] = new city("Helsinki, Finland", 60.1667, -24.9667,-2);
	City[j++] = new city("Hong Kong, China", 22.25,-114.1667, -8);
	City[j++] = new city("Jerusalem, Israel", 31.7833, -35.2333, -2);
	City[j++] = new city("London, England", 51.50, 0.1667,0);
	City[j++] = new city("Mexico City, Mexico", 19.4,99.15,6);
	City[j++] = new city("Moscow, Russia", 55.75, -37.5833, -3);
	City[j++] = new city("New Delhi, India",28.6, -77.2, -5.5);
	City[j++] = new city("Ottawa, Canada", 45.41667,75.7,5);
	City[j++] = new city("Paris, France", 48.8667, -2.667, -1);
	City[j++] = new city("Rio de Janeiro, Brazil",-22.90,43.2333,3);
	City[j++] = new city("Riyadh, Saudi Arabia", 24.633, -46.71667, -3);
	City[j++] = new city("Rome, Italy",41.90, -12.4833,-1);
	City[j++] = new city("Sydney, Australia",-33.8667,-151.2167,-10);
	City[j++] = new city("Tokyo, Japan", 35.70, -139.7667, -9);
	City[j++] = new city("Zurich, Switzerland", 47.3833, -8.5333,-1);
	City[j++] = new city("",0,0,0);
	City[j++] = new city("SURFRAD NETWORK",0,0,0);
	City[j++] = new city("Goodwin Creek, MS",34.2544444,89.8738888, 6);
	City[j++] = new city("Fort Peck, MT",48.310555,105.1025, 7);
	City[j++] = new city("Bondville, IL",40.055277,88.371944, 6);
	City[j++] = new city("Table Mountain, CO",40.125,105.23694, 7);
	City[j++] = new city("Desert Rock, NV",36.626,116.018,8);
	City[j++] = new city("Penn State, PA",40.72,77.93,5);
	City[j++] = new city("Canaan Valley, WV", 39.1, 79.4, 5);
	City[j++] = new city("Sioux Falls, SD", 43.733, 96.6233, 6);
	City[j++] = new city("",0,0,0);
	City[j++] = new city("ARM/CART NETWORK",0,0,0);
	City[j++] = new city("Atqasuk, AK", 70.47215, 157.4078, 9);
	City[j++] = new city("Barrow, AK", 71.30,156.683, 9);
	City[j++] = new city("Manus Island, PNG", -2.06, -147.425,-10);
	City[j++] = new city("Nauru Island", -0.52, -166.92, -12);
	City[j++] = new city("Darwin, Australia", -12.425, -130.891, -9.5);
	City[j++] = new city("SGP Central Facility", 36.6167, 97.5, 6);
	City[j++] = new city("",0,0,0);
	City[j++] = new city("ISIS NETWORK",0,0,0);
	City[j++] = new city("Albuquerque, NM", 35.04, 106.62,7);
	City[j++] = new city("Bismarck, ND", 46.77, 100.77,6);
	City[j++] = new city("Hanford, CA", 36.31, 119.63,8);
	City[j++] = new city("Madison, WI", 43.13, 89.33,6);
	City[j++] = new city("Oak Ridge, TN", 35.96, 84.37,5);
	City[j++] = new city("Salt Lake City, UT", 40.77,111.97,7);
	City[j++] = new city("Seattle, WA", 47.68, 122.25,8);
	City[j++] = new city("Sterling, VA", 38.98, 77.47,5);
	City[j++] = new city("Tallahassee, FL", 30.38, 84.37,5);

//*********************************************************************/

</script>
</head>

<body background="./NOAA Solar Position Calculator_files/sky3.jpg" bgcolor="#99CCFF">
<center>
<table border="0" cellpadding="5">
<tbody><tr><td>
<a href="http://www.doc.gov/"><img src="./NOAA Solar Position Calculator_files/doclogo.gif" alt="Dept of Commerce Seal" border="0"></a>
</td>
<td>
<center>
<font size="4"><b><a href="https://www.esrl.noaa.gov/index.html" target="_top">NOAA ESRL</a></b></font><br>
<font size="6"><b>Solar Position Calculator</b></font>
</center>
</td>
<td>
<center>
<a href="http://www.noaa.gov/"><img src="./NOAA Solar Position Calculator_files/noaaemblemt.gif" alt="National Oceanic and Atmospheric Administration" border="0"></a><br>
<a href="http://www.esrl.noaa.gov/"><font size="2">Earth System<br>Research Lab</font></a>
</center>
</td>
</tr>
</tbody></table>
</center>
<p>Please note that this web page is the old version of the NOAA Solar Calculator.
Back when this calculator was first created, we decided to use a non-standard
definition of longitude and time zone, to make coordinate entry less awkward.
So on this page, both longitude and time zone are defined as positive to the
west, instead of the international standard of positive to the east of the
Prime Meridian.
</p><p>We maintain this page as a courtesy to those people who, for whatever reason,
prefer the old calculator. For the rest of you, we encourage you to instead
<a href="http://www.esrl.noaa.gov/gmd/grad/solcalc/">click here to try the updated version of NOAA's Solar Calculator</a>
</p><hr>

<script language="JavaScript">

	function setLatLong(f, index)
	{
//Decimal degrees are passed in the array.  Temporarily store these decimal
// degs in lat and lon deg and have convLatLong modify them.
		f["latDeg"].value = City[index].lat;
		f["lonDeg"].value = City[index].lng;

//These are needed to prevent iterative adding of min and sec when set
//button is clicked.
		f["latMin"].value = 0;
		f["latSec"].value = 0;
		f["lonMin"].value = 0;
		f["lonSec"].value = 0;

//call convLatLong to convert decimal degrees into table form.
		convLatLong(f);

//Local time zone value set in table
		f["hrsToGMT"].value =  City[index].zoneHr;
	}

//	'isLeapYear' returns '1' if the yr is a leap year, '0' if it is not.

	function isLeapYear(yr)
	{
		return ((yr % 4 == 0 && yr % 100 != 0) || yr % 400 == 0);
	}

//*********************************************************************/

// isPosInteger returns false if the value is not a positive integer, true is
// returned otherwise.  The code is from taken from Danny Goodman's Javascript
// Handbook, p. 372.

	function isPosInteger(inputVal)
	{
		inputStr = "" + inputVal;
		for (var i = 0; i < inputStr.length; i++) {
			var oneChar = inputStr.charAt(i);
			if (oneChar < "0" || oneChar > "9")
				return false;
		}
		return true;
	}

//*********************************************************************/

	function isInteger(inputVal)
	{
		inputStr = "" + inputVal;
		if(inputStr == "NaN") return false;
		if(inputStr == "-NaN") return false;
		for (var i = 0; i < inputStr.length; i++)
		{
			var oneChar = inputStr.charAt(i);
			if (i == 0 && (oneChar == "-" || oneChar == "+"))
			{
				continue;
			}
			if (oneChar < "0" || oneChar > "9")
			{
				return false;
			}
		}
		return true;
	}


//*********************************************************************/

	function isNumber(inputVal)
	{
		var oneDecimal = false;
		var inputStr = "" + inputVal;
		for (var i = 0; i < inputStr.length; i++)
		{
			var oneChar = inputStr.charAt(i);
			if (i == 0 && (oneChar == "-" || oneChar == "+"))
			{
				continue;
			}
			if (oneChar == "." && !oneDecimal)
			{
				oneDecimal = true;
				continue;
			}
			if (oneChar < "0" || oneChar > "9")
			{
				return false;
			}
		}
		return true;
	}

//	'isValidInput' makes sure valid input is entered before calculating
//	the sunrise and sunset.  False is returned if an invalid entry was made,
//	true if the entry is valid.

	function isValidInput(f, index, latLongForm)
	{
		if (f["day"].value == "") {	//	see if the day field is empty
			alert("You must enter a day before attempting the calculation.");
			return false;
		}
		else if (f["year"].value == "") {	// see if year field is empty
			alert("You must enter a year before attempting the calculation.");
			return false;
		}
		else if (!isPosInteger(f["day"].value) || f["day"].value == 0)
		{
			alert("The day must be a positive integer.");
			return false;
		}
		else if (!isPosInteger(f["year"].value)) {
			alert("The year must be a positive integer.");
			return false;
		}
		else if (f["hour"].value == "") {	// see if hour field is empty
			alert("You must enter a time before attempting the calculation.");
			return false;
		}
		else if (!isPosInteger(f["hour"].value) ||
				!isPosInteger(f["mins"].value) ||
				!isPosInteger(f["secs"].value))
		{
			alert("The time fields must contain positive integers.");
			return false;
		}

//		else if ( ((f["ampm"].value == "AM") || (f["ampm"].value == "PM")) && (f["hour"].value > 12) )
//		{
//			alert("AM/PM hour must be between 0 and 12.");
//			return false;
//		}
//		else if ( (f["ampm"].value == "24") && (f["hour"].value > 23) )
//		{
//			alert("Hour must be between 0 and 23.");
//			return false;
//		}
		else if ( (f["hour"].value > 23) )
		{
			alert("Hour must be between 0 and 23.");
			return false;
		}
		else if (f["mins"].value > 59)
		{
			alert("Minutes must be between 0 and 59.");
			return false;
		}
		else if (f["secs"].value > 59)
		{
			alert("Seconds must be between 0 and 59.");
			return false;
		}

//	For the non-February months see if the day entered is greater than
//	the number of days in the selected month

		else if ((index != 1) && (f["day"].value > monthList[index].numdays))
		{
			alert("There are only " + monthList[index].numdays +
			" days in " + monthList[index].name + ".");
			return false;
		}

//	First see if the year entered is a leap year.  If so we have to make sure
//	the days entered is <= 29.  If not a leap year we make sure that the days
//	entered is <= 28.

		else if (index == 1) {	//	 month selected is February
			if (isLeapYear(f["year"].value)) {	//	year is a leap year
				if (f["day"].value > (monthList[index].numdays + 1)) {
					alert("There are only " +
					(monthList[index].numdays + 1) +
					" days in " + monthList[index].name + ".");
					return false;
				}
				else
					return true;
			}
			else {	//	year entered is not a leap year
				if (f["day"].value > monthList[index].numdays) {
					alert("There are only " +
					monthList[index].numdays +
					" days in " + monthList[index].name + ".");
					return false;
				}
				else
					return true;
			}
		}
		else
			return true;
	}

//convLatLong converts any type of lat/long input
//into  the table form and then handles bad input
//it is nested in the calcSun function.

function convLatLong(f){

		if(f["latDeg"].value == "")
		{
			f["latDeg"].value = 0;
		}
		if(f["latMin"].value == "")
		{
			f["latMin"].value = 0;
		}
		if(f["latSec"].value == "")
		{
			f["latSec"].value = 0;
		}
		if(f["lonDeg"].value == "")
		{
			f["lonDeg"].value = 0;
		}
		if(f["lonMin"].value == "")
		{
			f["lonMin"].value = 0;
		}
		if(f["lonSec"].value == "")
		{
			f["lonSec"].value = 0;
		}

		var neg = 0;
		if(f["latDeg"].value.charAt(0) == '-') {
			neg = 1;
		}

		if(neg != 1)
		{
			var latSeconds = (parseFloat(f["latDeg"].value))*3600 + parseFloat(f["latMin"].value)*60 + parseFloat(f["latSec"].value)*1;

			f["latDeg"].value = Math.floor(latSeconds/3600);
			f["latMin"].value = Math.floor((latSeconds-(parseFloat(f["latDeg"].value)*3600))/60);
			f["latSec"].value = Math.floor((latSeconds-(parseFloat(f["latDeg"].value)*3600)- (parseFloat(f["latMin"].value)*60)) + 0.5);

		}
		else if(parseFloat(f["latDeg"].value) > -1)
		{
			var latSeconds = parseFloat(f["latDeg"].value)*3600 - parseFloat(f["latMin"].value)*60 - parseFloat(f["latSec"].value)*1;

			f["latDeg"].value = "-0";
			f["latMin"].value = Math.floor((-latSeconds)/60);
			f["latSec"].value = Math.floor( (-latSeconds-(parseFloat(f["latMin"].value)*60)) + 0.5);

		}
		else
		{
			var latSeconds = parseFloat(f["latDeg"].value)*3600 - parseFloat(f["latMin"].value)*60 - parseFloat(f["latSec"].value)*1;

			f["latDeg"].value = Math.ceil(latSeconds/3600);
			f["latMin"].value = Math.floor((-latSeconds+(parseFloat(f["latDeg"].value)*3600))/60);
			f["latSec"].value = Math.floor((-latSeconds+(parseFloat(f["latDeg"].value)*3600) - (parseFloat(f["latMin"].value)*60)) + 0.5);
		}


		neg = 0;
		if(f["lonDeg"].value.charAt(0) == '-') {
			neg = 1;
		}

		if(neg != 1)
		{
        		var lonSeconds = parseFloat(f["lonDeg"].value)*3600 + parseFloat(f["lonMin"].value)*60 + parseFloat(f["lonSec"].value)*1;
			f["lonDeg"].value = Math.floor(lonSeconds/3600);
			f["lonMin"].value = Math.floor((lonSeconds-(parseFloat(f["lonDeg"].value)*3600))/60);
			f["lonSec"].value = Math.floor((lonSeconds-(parseFloat(f["lonDeg"].value)*3600)- (parseFloat(f["lonMin"].value))*60) + 0.5);
		}
		else if(parseFloat(f["lonDeg"].value) > -1)
		{
			var lonSeconds = parseFloat(f["lonDeg"].value)*3600 - parseFloat(f["lonMin"].value)*60 - parseFloat(f["lonSec"].value)*1;

			f["lonDeg"].value = "-0";
			f["lonMin"].value = Math.floor((-lonSeconds)/60);
			f["lonSec"].value = Math.floor( (-lonSeconds-(parseFloat(f["lonMin"].value)*60)) + 0.5);

		}
		else
		{
			var lonSeconds = parseFloat(f["lonDeg"].value)*3600 - parseFloat(f["lonMin"].value)*60 - parseFloat(f["lonSec"].value)*1;
		f["lonDeg"].value = Math.ceil(lonSeconds/3600);
		f["lonMin"].value = Math.floor((-lonSeconds+(parseFloat(f["lonDeg"].value)*3600))/60);
		f["lonSec"].value = Math.floor((-lonSeconds+(parseFloat(f["lonDeg"].value)*3600)-(parseFloat(f["lonMin"].value)*60)) + 0.5);
	}
	//Test for invalid lat/long input

		if(latSeconds > 323280){
			alert("You have entered an invalid latitude.\nSetting lat=89.8.");
			f["latDeg"].value = 89.8;
			f["latMin"].value = 0;
			f["latSec"].value = 0;
			}
		if(latSeconds < -323280){
			alert("You have entered an invalid latitude.\n  Setting lat= -89.8.");
			f["latDeg"].value = -89.8;
			f["latMin"].value = 0;
			f["latSec"].value = 0;
			}
		if(lonSeconds > 648000){
			alert("You have entered an invalid longitude.\n Setting lon= 180.");
			f["lonDeg"].value = 180;
			f["lonMin"].value = 0;
			f["lonSec"].value = 0;
			}
		if(lonSeconds < -648000){
			alert("You have entered an invalid latitude.\n Setting lon= -180.");
			f["lonDeg"].value = -180;
			f["lonMin"].value = 0;
			f["lonSec"].value =0;

}



//***********************************************************************/
//***********************************************************************/
//*												*/
//*This section contains subroutines used in calculating solar position */
//*												*/
//***********************************************************************/
//***********************************************************************/

// Convert radian angle to degrees

	function radToDeg(angleRad)
	{
		return (180.0 * angleRad / Math.PI);
	}

//*********************************************************************/

// Convert degree angle to radians

	function degToRad(angleDeg)
	{
		return (Math.PI * angleDeg / 180.0);
	}

//*********************************************************************/


//***********************************************************************/
//* Name:    calcDayOfYear								*/
//* Type:    Function									*/
//* Purpose: Finds numerical day-of-year from mn, day and lp year info  */
//* Arguments:										*/
//*   month: January = 1								*/
//*   day  : 1 - 31									*/
//*   lpyr : 1 if leap year, 0 if not						*/
//* Return value:										*/
//*   The numerical day of year							*/
//***********************************************************************/

	function calcDayOfYear(mn, dy, lpyr)
	{
		var k = (lpyr ? 1 : 2);
		var doy = Math.floor((275 * mn)/9) - k * Math.floor((mn + 9)/12) + dy -30;
		return doy;
	}


//***********************************************************************/
//* Name:    calcDayOfWeek								*/
//* Type:    Function									*/
//* Purpose: Derives weekday from Julian Day					*/
//* Arguments:										*/
//*   juld : Julian Day									*/
//* Return value:										*/
//*   String containing name of weekday						*/
//***********************************************************************/

	function calcDayOfWeek(juld)
	{
		var A = (juld + 1.5) % 7;
		var DOW = (A==0)?"Sunday":(A==1)?"Monday":(A==2)?"Tuesday":(A==3)?"Wednesday":(A==4)?"Thursday":(A==5)?"Friday":"Saturday";
		return DOW;
	}


//***********************************************************************/
//* Name:    calcJD									*/
//* Type:    Function									*/
//* Purpose: Julian day from calendar day						*/
//* Arguments:										*/
//*   year : 4 digit year								*/
//*   month: January = 1								*/
//*   day  : 1 - 31									*/
//* Return value:										*/
//*   The Julian day corresponding to the date					*/
//* Note:											*/
//*   Number is returned for start of day.  Fractional days should be	*/
//*   added later.									*/
//***********************************************************************/

	function calcJD(year, month, day)
	{
		if (month <= 2) {
			year -= 1;
			month += 12;
		}
		var A = Math.floor(year/100);
		var B = 2 - A + Math.floor(A/4);

		var JD = Math.floor(365.25*(year + 4716)) + Math.floor(30.6001*(month+1)) + day + B - 1524.5;
		return JD;
	}



//***********************************************************************/
//* Name:    calcDateFromJD								*/
//* Type:    Function									*/
//* Purpose: Calendar date from Julian Day					*/
//* Arguments:										*/
//*   jd   : Julian Day									*/
//* Return value:										*/
//*   String date in the form DD-MONTHNAME-YYYY					*/
//* Note:											*/
//***********************************************************************/

	function calcDateFromJD(jd)
	{
		var z = Math.floor(jd + 0.5);
		var f = (jd + 0.5) - z;

		if (z < 2299161) {
			var A = z;
		} else {
			alpha = Math.floor((z - 1867216.25)/36524.25);
			var A = z + 1 + alpha - Math.floor(alpha/4);
		}

		var B = A + 1524;
		var C = Math.floor((B - 122.1)/365.25);
		var D = Math.floor(365.25 * C);
		var E = Math.floor((B - D)/30.6001);

		var day = B - D - Math.floor(30.6001 * E) + f;
		var month = (E < 14) ? E - 1 : E - 13;
		var year = (month > 2) ? C - 4716 : C - 4715;

		// alert ("date: " + day + "-" + monthList[month-1].name + "-" + year);
		return (day + "-" + monthList[month-1].name + "-" + year);
	}


//***********************************************************************/
//* Name:    calcDayFromJD								*/
//* Type:    Function									*/
//* Purpose: Calendar day (minus year) from Julian Day			*/
//* Arguments:										*/
//*   jd   : Julian Day									*/
//* Return value:										*/
//*   String date in the form DD-MONTH						*/
//***********************************************************************/

	function calcDayFromJD(jd)
	{
		var z = Math.floor(jd + 0.5);
		var f = (jd + 0.5) - z;

		if (z < 2299161) {
			var A = z;
		} else {
			alpha = Math.floor((z - 1867216.25)/36524.25);
			var A = z + 1 + alpha - Math.floor(alpha/4);
		}

		var B = A + 1524;
		var C = Math.floor((B - 122.1)/365.25);
		var D = Math.floor(365.25 * C);
		var E = Math.floor((B - D)/30.6001);

		var day = B - D - Math.floor(30.6001 * E) + f;
		var month = (E < 14) ? E - 1 : E - 13;
		var year = (month > 2) ? C - 4716 : C - 4715;

		return ((day<10 ? "0" : "") + day + monthList[month-1].abbr);
	}


//***********************************************************************/
//* Name:    calcTimeJulianCent							*/
//* Type:    Function									*/
//* Purpose: convert Julian Day to centuries since J2000.0.			*/
//* Arguments:										*/
//*   jd : the Julian Day to convert						*/
//* Return value:										*/
//*   the T value corresponding to the Julian Day				*/
//***********************************************************************/

	function calcTimeJulianCent(jd)
	{
		var T = (jd - 2451545.0)/36525.0;
		return T;
	}


//***********************************************************************/
//* Name:    calcJDFromJulianCent							*/
//* Type:    Function									*/
//* Purpose: convert centuries since J2000.0 to Julian Day.			*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   the Julian Day corresponding to the t value				*/
//***********************************************************************/

	function calcJDFromJulianCent(t)
	{
		var JD = t * 36525.0 + 2451545.0;
		return JD;
	}


//***********************************************************************/
//* Name:    calGeomMeanLongSun							*/
//* Type:    Function									*/
//* Purpose: calculate the Geometric Mean Longitude of the Sun		*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   the Geometric Mean Longitude of the Sun in degrees			*/
//***********************************************************************/

	function calcGeomMeanLongSun(t)
	{
		var L0 = 280.46646 + t * (36000.76983 + 0.0003032 * t);
		while(L0 > 360.0)
		{
			L0 -= 360.0;
		}
		while(L0 < 0.0)
		{
			L0 += 360.0;
		}
		return L0;		// in degrees
	}


//***********************************************************************/
//* Name:    calGeomAnomalySun							*/
//* Type:    Function									*/
//* Purpose: calculate the Geometric Mean Anomaly of the Sun		*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   the Geometric Mean Anomaly of the Sun in degrees			*/
//***********************************************************************/

	function calcGeomMeanAnomalySun(t)
	{
		var M = 357.52911 + t * (35999.05029 - 0.0001537 * t);
		return M;		// in degrees
	}

//***********************************************************************/
//* Name:    calcEccentricityEarthOrbit						*/
//* Type:    Function									*/
//* Purpose: calculate the eccentricity of earth's orbit			*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   the unitless eccentricity							*/
//***********************************************************************/


	function calcEccentricityEarthOrbit(t)
	{
		var e = 0.016708634 - t * (0.000042037 + 0.0000001267 * t);
		return e;		// unitless
	}

//***********************************************************************/
//* Name:    calcSunEqOfCenter							*/
//* Type:    Function									*/
//* Purpose: calculate the equation of center for the sun			*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   in degrees										*/
//***********************************************************************/


	function calcSunEqOfCenter(t)
	{
		var m = calcGeomMeanAnomalySun(t);

		var mrad = degToRad(m);
		var sinm = Math.sin(mrad);
		var sin2m = Math.sin(mrad+mrad);
		var sin3m = Math.sin(mrad+mrad+mrad);

		var C = sinm * (1.914602 - t * (0.004817 + 0.000014 * t)) + sin2m * (0.019993 - 0.000101 * t) + sin3m * 0.000289;
		return C;		// in degrees
	}

//***********************************************************************/
//* Name:    calcSunTrueLong								*/
//* Type:    Function									*/
//* Purpose: calculate the true longitude of the sun				*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   sun's true longitude in degrees						*/
//***********************************************************************/


	function calcSunTrueLong(t)
	{
		var l0 = calcGeomMeanLongSun(t);
		var c = calcSunEqOfCenter(t);

		var O = l0 + c;
		return O;		// in degrees
	}

//***********************************************************************/
//* Name:    calcSunTrueAnomaly							*/
//* Type:    Function									*/
//* Purpose: calculate the true anamoly of the sun				*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   sun's true anamoly in degrees							*/
//***********************************************************************/

	function calcSunTrueAnomaly(t)
	{
		var m = calcGeomMeanAnomalySun(t);
		var c = calcSunEqOfCenter(t);

		var v = m + c;
		return v;		// in degrees
	}

//***********************************************************************/
//* Name:    calcSunRadVector								*/
//* Type:    Function									*/
//* Purpose: calculate the distance to the sun in AU				*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   sun radius vector in AUs							*/
//***********************************************************************/

	function calcSunRadVector(t)
	{
		var v = calcSunTrueAnomaly(t);
		var e = calcEccentricityEarthOrbit(t);

		var R = (1.000001018 * (1 - e * e)) / (1 + e * Math.cos(degToRad(v)));
		return R;		// in AUs
	}

//***********************************************************************/
//* Name:    calcSunApparentLong							*/
//* Type:    Function									*/
//* Purpose: calculate the apparent longitude of the sun			*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   sun's apparent longitude in degrees						*/
//***********************************************************************/

	function calcSunApparentLong(t)
	{
		var o = calcSunTrueLong(t);

		var omega = 125.04 - 1934.136 * t;
		var lambda = o - 0.00569 - 0.00478 * Math.sin(degToRad(omega));
		return lambda;		// in degrees
	}

//***********************************************************************/
//* Name:    calcMeanObliquityOfEcliptic						*/
//* Type:    Function									*/
//* Purpose: calculate the mean obliquity of the ecliptic			*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   mean obliquity in degrees							*/
//***********************************************************************/

	function calcMeanObliquityOfEcliptic(t)
	{
		var seconds = 21.448 - t*(46.8150 + t*(0.00059 - t*(0.001813)));
		var e0 = 23.0 + (26.0 + (seconds/60.0))/60.0;
		return e0;		// in degrees
	}

//***********************************************************************/
//* Name:    calcObliquityCorrection						*/
//* Type:    Function									*/
//* Purpose: calculate the corrected obliquity of the ecliptic		*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   corrected obliquity in degrees						*/
//***********************************************************************/

	function calcObliquityCorrection(t)
	{
		var e0 = calcMeanObliquityOfEcliptic(t);

		var omega = 125.04 - 1934.136 * t;
		var e = e0 + 0.00256 * Math.cos(degToRad(omega));
		return e;		// in degrees
	}

//***********************************************************************/
//* Name:    calcSunRtAscension							*/
//* Type:    Function									*/
//* Purpose: calculate the right ascension of the sun				*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   sun's right ascension in degrees						*/
//***********************************************************************/

	function calcSunRtAscension(t)
	{
		var e = calcObliquityCorrection(t);
		var lambda = calcSunApparentLong(t);

		var tananum = (Math.cos(degToRad(e)) * Math.sin(degToRad(lambda)));
		var tanadenom = (Math.cos(degToRad(lambda)));
		var alpha = radToDeg(Math.atan2(tananum, tanadenom));
		return alpha;		// in degrees
	}

//***********************************************************************/
//* Name:    calcSunDeclination							*/
//* Type:    Function									*/
//* Purpose: calculate the declination of the sun				*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   sun's declination in degrees							*/
//***********************************************************************/

	function calcSunDeclination(t)
	{
		var e = calcObliquityCorrection(t);
		var lambda = calcSunApparentLong(t);

		var sint = Math.sin(degToRad(e)) * Math.sin(degToRad(lambda));
		var theta = radToDeg(Math.asin(sint));
		return theta;		// in degrees
	}

//***********************************************************************/
//* Name:    calcEquationOfTime							*/
//* Type:    Function									*/
//* Purpose: calculate the difference between true solar time and mean	*/
//*		solar time									*/
//* Arguments:										*/
//*   t : number of Julian centuries since J2000.0				*/
//* Return value:										*/
//*   equation of time in minutes of time						*/
//***********************************************************************/

	function calcEquationOfTime(t)
	{
		var epsilon = calcObliquityCorrection(t);
		var l0 = calcGeomMeanLongSun(t);
		var e = calcEccentricityEarthOrbit(t);
		var m = calcGeomMeanAnomalySun(t);

		var y = Math.tan(degToRad(epsilon)/2.0);
		y *= y;

		var sin2l0 = Math.sin(2.0 * degToRad(l0));
		var sinm   = Math.sin(degToRad(m));
		var cos2l0 = Math.cos(2.0 * degToRad(l0));
		var sin4l0 = Math.sin(4.0 * degToRad(l0));
		var sin2m  = Math.sin(2.0 * degToRad(m));

		var Etime = y * sin2l0 - 2.0 * e * sinm + 4.0 * e * y * sinm * cos2l0
				- 0.5 * y * y * sin4l0 - 1.25 * e * e * sin2m;

		return radToDeg(Etime)*4.0;	// in minutes of time
	}








// Return the hour angle for the given location, decl, and time of day

	function calcHourAngle(time, longitude, eqtime)
	{
		return (15.0*(time - (longitude/15.0) - (eqtime/60.0)));
		// in degrees
	}


// Returns decimal latitude from deg, min, sec entered in the form

	function getLatitude(latLongForm)

	{
		var neg = 0;
		var degs = parseFloat(latLongForm["latDeg"].value);
		if (latLongForm["latDeg"].value.charAt(0) == '-') {
			neg = 1;
		}

		var mins = parseFloat(latLongForm["latMin"].value);

		var secs = parseFloat(latLongForm["latSec"].value);

		if(neg != 1){
			var decLat// = degs + (mins / 60) + (secs / 3600);
		} else if(neg == 1){
			var decLat// = degs - (mins / 60) - (secs / 3600);
		} else {
			return -9999;
		}
		return decLat;

	}
// Returns decimal longitude from the deg, min, sec entered in the form

	function getLongitude(latLongForm)

	{
		var neg = 0;
		var degs = parseFloat(latLongForm["lonDeg"].value);
		if (latLongForm["lonDeg"].value.charAt(0) == '-') {
			neg = 1;
		}

		var mins = parseFloat(latLongForm["lonMin"].value);

		var secs = parseFloat(latLongForm["lonSec"].value);

		var decLon = degs + (mins / 60) + (secs / 3600);

		if(neg != 1){
        		var decLon = degs + (mins / 60) + (secs / 3600);
		} else if(neg == 1){
        		var decLon = degs - (mins / 60) - (secs / 3600);
		} else {
			return -9999;
		}
		return decLon;

	}


// *****************************************************
// *****************************************************
// ***********  Main calculation routine  **************
// *****************************************************
// *****************************************************

//***********************************************************************/
//* Name:    calcSun									*/
//* Type:    Main Function called by form controls				*/
//* Purpose: calculate solar position for the entered date, time and	*/
//*		location.  Results are reported in azimuth and elevation	*/
//*		(in degrees) and cosine of solar zenith angle.			*/
//* Arguments:										*/
//*   riseSetForm : for displaying results					*/
//*   latLongForm : for reading latitude and longitude data			*/
//*   index : daylight saving yes/no select					*/
//*   index2 : city select index							*/
//* Return value:										*/
//*   none											*/
//*	(fills riseSetForm text fields with results of calculations)	*/
//***********************************************************************/

	function calcSun(riseSetForm, latLongForm, index, index2)
	{
		if(index2 != 0)
		{
			setLatLong(latLongForm, index2);
		}
		var latitude = getLatitude(latLongForm);
		var longitude = getLongitude(latLongForm);
		var indexRS = riseSetForm.mos.selectedIndex
		if (isValidInput(riseSetForm, indexRS, latLongForm))
		{
			if((latitude >= -90) && (latitude < -89.8))
			{
				alert("All latitudes between 89.8 and 90 S\n will be set to -89.8.");
				latLongForm["latDeg"].value = -89.8;
				latitude = -89.8;
			}
			if ((latitude <= 90) && (latitude > 89.8))
			{
		            alert("All latitudes between 89.8 and 90 N\n will be set to 89.8.");
				latLongForm["latDeg"].value = 89.8;
				latitude = 89.8;
			}

	//*****	Get calc date/time

//			var julDay = calcJulianDay(indexRS,
//				parseFloat(riseSetForm["day"].value),
//				isLeapYear(riseSetForm["year"].value));

			var zone = parseFloat(latLongForm["hrsToGMT"].value);
			var daySavings = YesNo[index].value;  // = 0 (no) or 60 (yes)

			if(zone > 12 || zone < -12.5)
			{
				alert("The offset must be between -12.5 and 12.  \n Setting \"Off-Set\"=0");
				zone = "0";
				latLongForm["hrsToGMT"].value = zone;
			}

			var ss = parseFloat(riseSetForm["secs"].value);
			var mm = parseFloat(riseSetForm["mins"].value);
			var hh = parseFloat(riseSetForm["hour"].value) - (daySavings/60);
			if(riseSetForm.ampm[1].checked)
			{
				hh += 12;
			}
			while (hh > 23)
			{
				hh -= 24;
			}
			riseSetForm["hour"].value = hh + (daySavings/60);
			if (mm > 9)
			{
				riseSetForm["mins"].value = mm;
			}
			else
			{
				riseSetForm["mins"].value = "0" + mm;
			}
			if (ss > 9)
			{
				riseSetForm["secs"].value = ss;
			}
			else
			{
				riseSetForm["secs"].value = "0" + ss;
			}
			riseSetForm.ampm[2].checked = 1;

// timenow is GMT time for calculation
			timenow = hh + mm/60 + ss/3600 + zone;	// in hours since 0Z
			//alert("timenow = " + timenow);


			var JD = (calcJD(parseFloat(riseSetForm["year"].value), indexRS + 1, parseFloat(riseSetForm["day"].value)));
			var dow = calcDayOfWeek(JD);
			var doy = calcDayOfYear(indexRS + 1, parseFloat(riseSetForm["day"].value), isLeapYear(riseSetForm["year"].value));
			var T = calcTimeJulianCent(JD + timenow/24.0);
			//var L0 = calcGeomMeanLongSun(T);
			//var M = calcGeomMeanAnomalySun(T);
			//var e = calcEccentricityEarthOrbit(T);
			//var C = calcSunEqOfCenter(T);
			//var O = calcSunTrueLong(T);
			//var v = calcSunTrueAnomaly(T);
			var R = calcSunRadVector(T);
			//var lambda = calcSunApparentLong(T);
			//var epsilon0 = calcMeanObliquityOfEcliptic(T);
			//var epsilon = calcObliquityCorrection(T);
			var alpha = calcSunRtAscension(T);
			var theta = calcSunDeclination(T);
			var Etime = calcEquationOfTime(T);

			var eqTime = Etime;
			var solarDec = theta; // in degrees
			var earthRadVec = R;

			riseSetForm["eqTime"].value = (Math.floor(100*eqTime))/100;
			riseSetForm["solarDec"].value = (Math.floor(100*(solarDec)))/100;

			var solarTimeFix = eqTime - 4.0 * longitude + 60.0 * zone;
			var trueSolarTime = hh * 60.0 + mm + ss/60.0 + solarTimeFix;
			// in minutes

			while (trueSolarTime > 1440)
			{
				trueSolarTime -= 1440;
			}

			//var hourAngle = calcHourAngle(timenow, longitude, eqTime);
			var hourAngle = trueSolarTime / 4.0 - 180.0;
			// Thanks to Louis Schwarzmayr for finding our error,
			// and providing the following 4 lines to fix it:
			if (hourAngle < -180)
			{
			  hourAngle += 360.0;
			}
			// alert ("Hour Angle = " + hourAngle);

			var haRad = degToRad(hourAngle);

			var csz = Math.sin(degToRad(latitude)) *
				Math.sin(degToRad(solarDec)) +
				Math.cos(degToRad(latitude)) *
				Math.cos(degToRad(solarDec)) * Math.cos(haRad);
			if (csz > 1.0)
			{
				csz = 1.0;
			} else if (csz < -1.0)
			{
				csz = -1.0;
			}
			var zenith = radToDeg(Math.acos(csz));

			var azDenom = ( Math.cos(degToRad(latitude)) *
					Math.sin(degToRad(zenith)) );
			if (Math.abs(azDenom) > 0.001) {
				azRad = (( Math.sin(degToRad(latitude)) *
					Math.cos(degToRad(zenith)) ) -
					Math.sin(degToRad(solarDec))) / azDenom;
				if (Math.abs(azRad) > 1.0) {
					if (azRad < 0) {
						azRad = -1.0;
					} else {
						azRad = 1.0;
					}
				}

				var azimuth = 180.0 - radToDeg(Math.acos(azRad));

				if (hourAngle > 0.0) {
					azimuth = -azimuth;
				}
			} else {
				if (latitude > 0.0) {
					azimuth = 180.0;
				} else {
					azimuth = 0.0;
				}
			}
			if (azimuth < 0.0) {
				azimuth += 360.0;
			}

			exoatmElevation = 90.0 - zenith;
			if (exoatmElevation > 85.0) {
				refractionCorrection = 0.0;
			} else {
				te = Math.tan (degToRad(exoatmElevation));
				if (exoatmElevation > 5.0) {
					refractionCorrection = 58.1 / te - 0.07 / (te*te*te) +
						0.000086 / (te*te*te*te*te);
				} else if (exoatmElevation > -0.575) {
					refractionCorrection = 1735.0 + exoatmElevation *
						(-518.2 + exoatmElevation * (103.4 +
						exoatmElevation * (-12.79 +
						exoatmElevation * 0.711) ) );
				} else {
					refractionCorrection = -20.774 / te;
				}
				refractionCorrection = refractionCorrection / 3600.0;
			}

			solarZen = zenith - refractionCorrection;

			if(solarZen < 108.0) { // astronomical twilight
			  riseSetForm["azimuth"].value = (Math.floor(100*
azimuth))/100;
			  riseSetForm["elevation"].value = (Math.floor(100*
(90.0 - solarZen)))/100;
			  if (solarZen < 90.0) {
				riseSetForm["coszen"].value =
(Math.floor(10000.0*(Math.cos(degToRad(solarZen)))))/10000.0;
			  } else {
				riseSetForm["coszen"].value = 0.0;
			  }
			} else {  // do not report az & el after astro twilight
			  riseSetForm["azimuth"].value = "dark";
			  riseSetForm["elevation"].value = "dark";
			  riseSetForm["coszen"].value = 0.0;
			}

		//***********Conv lat and long
			convLatLong(latLongForm);
		} else {			// end of IF ISVALIDINPUT
			riseSetForm["azimuth"].value = "error";
			riseSetForm["elevation"].value = "error";
			riseSetForm["eqTime"].value = "error";
			riseSetForm["solarDec"].value = "error";
			riseSetForm["coszen"].value = "error";

			// alert("Invalid Input");
		}
	}

</script>

<form name="cityLatLong">
	<center><table border="">
	<tbody><tr>
		<td align="CENTER"><h5>City:</h5></td>
		<td></td>
		<td align="CENTER"><h5>Deg:</h5></td>
		<td align="CENTER"><h5>Min:</h5></td>
		<td align="CENTER"><h5>Sec:</h5></td>
		<td align="CENTER" colspan="2"><h5><a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/timezone.html">Time 				Zone</a></h5></td>
	</tr>

	<tr>
	<td align="TOP">
	<center>
	<select name="cities" onchange="calcSun(solPosCalc, cityLatLong, cityLatLong.dayAns.selectedIndex, cityLatLong.cities.selectedIndex);">

		<script language="JavaScript">
	    		for (i = 0; i < City.length; i++) {
				if(City[i].name == "Boulder, CO")
				{
				document.writeln("<OPTION SELECTED>" + City[i].name);
	    		}
				else
				document.writeln("<OPTION>" + City[i].name);
				}

		</script><option>Enter Lat/Long --&gt;
</option><option>
</option><option>US CITIES
</option><option>Albuquerque, NM
</option><option>Anchorage, AK
</option><option>Atlanta, GA
</option><option>Austin, TX
</option><option>Birmingham, AL
</option><option>Bismarck, ND
</option><option>Boston, MA
</option><option selected="">Boulder, CO
</option><option>Chicago, IL
</option><option>Dallas, TX
</option><option>Denver, CO
</option><option>Detroit, MI
</option><option>Honolulu, HI
</option><option>Houston, TX
</option><option>Indianapolis, IN
</option><option>Jackson, MS
</option><option>Kansas City, MO
</option><option>Los Angeles, CA
</option><option>Menomonee Falls, WI
</option><option>Miami, FL
</option><option>Minneapolis, MN
</option><option>New Orleans, LA
</option><option>New York City, NY
</option><option>Oklahoma City, OK
</option><option>Philadelphia, PA
</option><option>Phoenix, AZ
</option><option>Pittsburgh, PA
</option><option>Portland, ME
</option><option>Portland, OR
</option><option>Raleigh, NC
</option><option>Richmond, VA
</option><option>Saint Louis, MO
</option><option>San Antonio, TX
</option><option>San Diego, CA
</option><option>San Francisco, CA
</option><option>Seattle, WA
</option><option>Washington DC
</option><option>
</option><option>WORLD CITIES
</option><option>Beijing, China
</option><option>Berlin, Germany
</option><option>Bombay, India
</option><option>Buenos Aires, Argentina
</option><option>Cairo, Egypt
</option><option>Cape Town, South Africa
</option><option>Caracas, Venezuela
</option><option>Helsinki, Finland
</option><option>Hong Kong, China
</option><option>Jerusalem, Israel
</option><option>London, England
</option><option>Mexico City, Mexico
</option><option>Moscow, Russia
</option><option>New Delhi, India
</option><option>Ottawa, Canada
</option><option>Paris, France
</option><option>Rio de Janeiro, Brazil
</option><option>Riyadh, Saudi Arabia
</option><option>Rome, Italy
</option><option>Sydney, Australia
</option><option>Tokyo, Japan
</option><option>Zurich, Switzerland
</option><option>
</option><option>SURFRAD NETWORK
</option><option>Goodwin Creek, MS
</option><option>Fort Peck, MT
</option><option>Bondville, IL
</option><option>Table Mountain, CO
</option><option>Desert Rock, NV
</option><option>Penn State, PA
</option><option>Canaan Valley, WV
</option><option>Sioux Falls, SD
</option><option>
</option><option>ARM/CART NETWORK
</option><option>Atqasuk, AK
</option><option>Barrow, AK
</option><option>Manus Island, PNG
</option><option>Nauru Island
</option><option>Darwin, Australia
</option><option>SGP Central Facility
</option><option>
</option><option>ISIS NETWORK
</option><option>Albuquerque, NM
</option><option>Bismarck, ND
</option><option>Hanford, CA
</option><option>Madison, WI
</option><option>Oak Ridge, TN
</option><option>Salt Lake City, UT
</option><option>Seattle, WA
</option><option>Sterling, VA
</option><option>Tallahassee, FL

	</option></select>
	</center>
	</td>
	<td align="CENTER"><h5><a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/glossary.html#latitude">Lat</a>:
		<br>North=+<br>South=<font size="4">-</font>
	</h5></td>
	<td><input type="text" name="latDeg" value="40" size="4"></td>
	<td><input type="text" name="latMin" value="7" size="4"></td>
	<td><input type="text" name="latSec" value="30" size="4"></td>
	<td rowspan="2" align="CENTER"><h5>Offset<br>to
		<a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/glossary.html#UTC">UTC</a><br>(MST=+7):<br></h5>
	<input type="text" name="hrsToGMT" value="7" size="5"></td>
	<td rowspan="2" align="CENTER"><h5>
		<a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/glossary.html#daylightsavingtime">Daylight<br>Saving<br>Time</a>:
		<br></h5>
	<select name="dayAns" onchange="calcSun(solPosCalc, cityLatLong, cityLatLong.dayAns.selectedIndex, cityLatLong.cities.selectedIndex);">
	<script language="JavaScript">
		for(i=0; i < YesNo.length; i++)
		{
			document.writeln("<OPTION>" + YesNo[i].daySave);
		}
	</script><option>No
</option><option>Yes

	</option></select>
	</td>
	</tr>

	<tr>
		<td align="CENTER"><h5><a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/sollinks.html#latlong">Click here for help finding<br>
			your lat/long coordinates</a>
		</h5></td>

		<td align="CENTER"><h5><a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/glossary.html#longitude">Long</a>:
			<br>East=<font size="4">-</font><br>West=+
		</h5></td>

		<td><input type="text" name="lonDeg" value="105" size="4"></td>
		<td><input type="text" name="lonMin" value="14" size="4"></td>
		<td><input type="text" name="lonSec" value="13" size="4"></td>
	</tr>
	<tr>
		<td colspan="7">
		<b>Note:</b>  To manually enter latitude/longitude, select <b>Enter
			Lat/Long -&gt;</b> from the<br>City pulldown box, and enter the
			values in the text boxes to the right.
		</td>
	</tr>
	</tbody></table>



<form name="solPosCalc">
	<center><table border="">
	<tbody><tr>
	  	<td align="CENTER"><h5>Month:</h5></td>
		<td align="CENTER"><h5>Day:</h5></td>
		<td align="CENTER"><h5>Year (e.g. 2000):</h5></td>
		<td align="CENTER"><h5>Time: (hh:mm:ss)</h5></td>
	</tr>
	<tr>
	  	<td>
			<select name="mos" onchange="calcSun(solPosCalc, cityLatLong, cityLatLong.dayAns.selectedIndex, cityLatLong.cities.selectedIndex);">
		  	<script language="JavaScript">
	 			dateObj1 = new Date();
			    	thismonth = dateObj1.getMonth();
			     	today = dateObj1.getDate();
			     	for (i = 0; i < monthList.length; i++) {
				     	if (i == thismonth) {
				     	document.writeln("<OPTION SELECTED>" + monthList[i].name);
        				}
					else {
					document.writeln("<OPTION>" + monthList[i].name);
					}
				}
	    		</script><option>January
</option><option selected="">February
</option><option>March
</option><option>April
</option><option>May
</option><option>June
</option><option>July
</option><option>August
</option><option>September
</option><option>October
</option><option>November
</option><option>December

	  		</option></select>
	  	</td>
			<script language="JavaScript">
				dateObj2 = new Date();
				thisday = dateObj2.getDate();
				document.writeln("<TD><CENTER><INPUT TYPE=\"text\" NAME=\"day\" SIZE=\"2\" VALUE=\"" + thisday + "\"></TD>");
			</script><td><center><input type="text" name="day" size="2" value="11"></center></td>


			<script language="JavaScript">
				dateObj3 = new Date();
				thisYear = dateObj3.getYear();
				if(thisYear <=199){
					thisYear=(thisYear*1)+1900;
				}
				document.writeln("<TD><CENTER><INPUT TYPE=\"text\" NAME=\"year\" SIZE=\"4\"VALUE=\"" + thisYear*1 + "\"></TD>");
			</script><td><center><input type="text" name="year" size="4" value="2017"></center></td>


			<td><center>
			<script language="JavaScript">
				dateObj4 = new Date();
				nowhour = dateObj4.getHours();
				nowmins = dateObj4.getMinutes();
				nowsecs = dateObj4.getSeconds();
				document.writeln("<INPUT TYPE=\"text\" NAME=\"hour\" SIZE=\"2\"VALUE=\"" + nowhour*1 + "\"> <b>:</b>");
				document.writeln("<INPUT TYPE=\"text\" NAME=\"mins\" SIZE=\"2\"VALUE=\"" + nowmins*1 + "\"> <b>:</b>");
				document.writeln("<INPUT TYPE=\"text\" NAME=\"secs\" SIZE=\"2\"VALUE=\"" + nowsecs*1 + "\">");
			</script><input type="text" name="hour" size="2" value="9"> <b>:</b>
<input type="text" name="mins" size="2" value="52"> <b>:</b>
<input type="text" name="secs" size="2" value="59">

			<input type="radio" name="ampm" value="AM">AM
			<input type="radio" name="ampm" value="PM">PM
			<input type="radio" name="ampm" value="24" checked="">24hr
			</center></td>
	</tr>
	</tbody></table>

<br>

	  	<input type="button" name="RiseSet" value="  Calculate Solar Position  " onclick="calcSun(solPosCalc, cityLatLong, cityLatLong.dayAns.selectedIndex, cityLatLong.cities.selectedIndex);">
<br>
<br>

<table border="">
	<tbody><tr>
		<td align="CENTER"><h5>
		<a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/glossary.html#equationoftime">Equation <br>of Time</a>
			<br>(minutes):</h5></td>
		<td align="CENTER"><h5>
		<a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/glossary.html#solardeclination">Solar<br>Declination</a><br>
			(degrees):</h5></td>
		<td align="CENTER"><h5>Solar<br>
		<a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/glossary.html#azimuthelevation">Azimuth</a>:</h5></td>
		<td align="CENTER"><h5>Solar<br>
		<a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/glossary.html#azimuthelevation">Elevation</a>:</h5></td>
		<td align="CENTER"><h5>cosine of<br>solar
		<a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/glossary.html#zenithangle">zenith<br>angle</a></h5></td>
	</tr>
	<tr>
		<td><center><input type="text" name="eqTime" size="8"></center></td>
		<td><center><input type="text" name="solarDec" size="8"></center></td>
		<td><center><input type="text" name="azimuth" size="8"></center></td>
		<td><center><input type="text" name="elevation" size="8"></center></td>
		<td><center><input type="text" name="coszen" size="8"></center></td>
	</tr>
	<tr>
	<td colspan="5" align="center"><h5>Azimuth is measured in degrees clockwise from north.<br>
			Elevation is measured in degrees up from the horizon.<br>
			Az &amp; El both report <i>dark</i> after <a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/glossary.html#astronomicaltwilight">astronomical twilight</a>.
	</h5></td>
</tr></tbody></table>

</center>
</form>
</center></form>

<hr>
<b><h3>Directions:</h3></b><br>

<h4>
<ol>
<li>
<font size="2">
Select a location from the City pulldown menu, <u>OR</u> select <b>"Enter
Lat/Long -&gt;"</b> from the pulldown menu, and manually enter the latitude,
longitude and time zone information in the appropriate text boxes. For this calculator,
latitude is positive to the NORTH, and longitude is positive to the WEST of
the prime meridian.
<p></p>
<p>
Latitude and Longitude can be in deg/min/sec, or decimal degrees entered in
the "Deg:" field.  (If you enter decimal degrees in the degrees field, please
clear the minutes and seconds fields, or they will be added in.)  If you
select a city from the pulldown menu, the latitude, longitude and time zone fields
will be filled in by the program.  If you want to input latitude, longitude
or time zone manually, <u>be sure to
select "Enter Lat/Long --&gt;" from the City pulldown box, or your numbers will
be overwritten</u> by the selected city's location.
</p>
</font>
</li>
<li>
<p>
<font size="2">You can enter a different time zone for a location by selecting
"Enter Lat/Long --&gt;" in the City pulldown box.  Otherwise the time zone
associated with the selected city's Local Standard Time will be automatically
entered.
Selecting "Yes" in the Daylight Saving field will cause the solar position
calculation to assume the current time has been adjusted forward one hour from
standard time.  If you are uncertain of the time zone for a location, refer to
our <a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/timezone.html">Time Zone Table</a>.
</font></p><font size="2">
</font>
</li>
<li>
<p>
<font size="2">The program retrieves the current date and time from your computer, and fills
in these values in the date/time fields.  To perform calculations for a
different date, simply select the month in the pulldown box, and enter the
day and four digit year in the appropriate input boxes.  Time of day for the
calculation can be changed in the same way.
</font></p><font size="2">
</font>
</li>
<li>
<p>
<font size="2">Hit the "Calculate Solar Position" button.  Once the calculations
are complete, you may use your browser's "Print" function to obtain a hardcopy
of the results.  Results are given in the following units:  Equation of Time in
minutes of time; Solar Declination in degrees, with positive to the north;
Azimuth in degrees clockwise from north; Elevation in degrees up from the
horizon; Cosine of Solar Zenith Angle is unitless.
</font></p><font size="2">
</font>
</li>
<li>
<p>
<font size="2">Note that for latitudes greater than
72 north or less than 72 south, accuracy may be lower due in
part to the effects of
<a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/glossary.html#atmosphericrefraction">atmospheric refraction</a>.
</font></p><font size="2">
</font>
</li>
</ol>
</h4>


<br>
<hr>

<h4>
<table border="0" width="100%">
<tbody><tr>
<td align="left">
<a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/sunrise.html">Sunrise/Sunset Calculator</a><br>
<a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/calcdetails.html">Calculation Details</a><br>
<a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/sollinks.html">Solar Calculator Links</a><br>
</td>

<td align="center">
<a href="http://www.noaa.gov/"><img src="./NOAA Solar Position Calculator_files/noaaemblemt.gif" border="0" alt="NOAA Emblem"></a>
</td>

<td align="right">
<a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/timezone.html">Time Zone Table</a><br>
<a href="https://www.esrl.noaa.gov/gmd/grad/solcalc/glossary.html">Solar Calculator Glossary</a><br>
<a href="https://www.esrl.noaa.gov/index.html">Back to SRRB Homepage</a><br>
</td>
</tr>
</tbody></table>

</h4>

<center>by
<a href="mailto:webmaster-srrb.gmd@noaa.gov">Chris Cornwall</a>,
Aaron Horiuchi and Chris Lehman<br>
	<script>
		document.write("Last Updated on " + document.lastModified + ".");
	</script>Last Updated on 02/11/2017 09:52:59.
</center>



</body></html>